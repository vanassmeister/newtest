ТЕОРЕТИЧЕСКАЯ ЧАСТЬ

1)

select ts.* from tb_source ts 
join (select distinct cx from tb_rel) tt on ts.cx = tt.cx
where ts.title like 'title 1%'

Таблица tb_rel содержит более 500 000 записей. Но уникальных значений cx в ней 
чуть более 9000. Нет смысла джойнить tb_source и tb_rel напрямую. Потому джойним
tb_source с подзапросом "select distinct cx from tb_rel", чтобы получить записи
tb_source для которых существуют записи в таблице tb_rel.

2)

select count(1) from tb_source ts
join (select distinct cx from tb_rel group by cx, ndc having count(1) > 2) tt on ts.cx = tt.cx

Результат: 2114

Подзапросом выбираем значения cx для которых есть более двух повторяющихся 
значений ndc. Джойним подзапрос с таблицей ts_source и считаем число строк в 
результате.


3) Рекомендации следующие:

Добавить индексы. Индексы замедляют вставку, но поскольку таблицы будут обновляться редко,
потеря скорости вставки окупится повышением скорости поиска:
	Добавить индекс по полю cx в таблицу tb_source для ускорения джойнов.
	Добавить индекс по полю cx в таблицу tb_rel для ускорения джойнов.
	Добавить индекс по полю title в таблицу tb_source для ускорения поиска.

Добавить первичные ключи. Ни одну из записей таблиц tb_source и tb_rel нельзя однозначно идентифицировать
по существующему набору полей. Нужно:
	Добавить целочисленное автоинкрементное поле id в таблицу tb_source
	Добавить целочисленное автоинкрементное поле id в таблицу tb_rel
Первичные ключи пригодятся при отображении данных на web-странице (например для CRUD-функций)

Сменить тип полей cx и rx с varchar(10) на int. Хранить целые числа в строках расточительно.
Расходуется больше места на диске, больше памяти и процессорного времени на обработку.

